# -*- coding: utf-8 -*-
"""243 LLM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15ylNFSxRhblZaTMyEvpw8msq4GMN8pci
"""

import openai
import pandas as pd
import json
# === SET YOUR OPENAI API KEY ===
openai.api_key = "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"  # Replace with your actual key

# === LOAD DATA ===
csv_path = "Philadelphia.csv"  # Path to your housing dataset
housing_data = pd.read_csv(csv_path)
# Required columns to match
required_cols = ['SQFT', 'BEDS', 'BATHS', 'RENT_PRICE', 'BUILDING_TYPE']

# Drop rows with missing critical values
housing_data.dropna(subset=required_cols, inplace=True)

# === LISTING FILTERING FUNCTION ===
def extract_filters_with_gpt(user_query):
    print("ðŸ§  User Query Received by GPT:", user_query)

    system_prompt = (
        "Extract structured housing needs from the user query in JSON. "
        "Include fields like min_sqft, min_bedrooms, min_bathrooms, max_price, "
        "building_type (house/apartment), and amenities_required (list of strings like 'pool', 'gym'). "
        "Do not explain anything, just return valid JSON."
    )

    response = openai.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_query}
        ],
        temperature=0.2
    )

    raw_text = response.choices[0].message.content.strip()
    print("ðŸ“¦ GPT Response:", raw_text)

    try:
        filters = json.loads(raw_text)
        print("âœ… Parsed Filters:", filters)
        return filters
    except json.JSONDecodeError as e:
        print("âš ï¸ JSON decoding error:", e)
        return {}

    system_prompt = (
        "Extract structured housing needs from the user query in JSON. "
        "Include fields like min_sqft, min_bedrooms, min_bathrooms, max_price, "
        "building_type (house/apartment), and amenities_required (list of strings like 'pool', 'gym'). "
        "Do not explain anything, just return valid JSON."
    )
    response = openai.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_query}
        ],
        temperature=0.2
    )
    raw_text = response.choices[0].message.content.strip()
    print("ðŸ“¦ GPT Response:", raw_text)
    try:
        filters = json.loads(raw_text)
        print("âœ… Parsed Filters:", filters)
        return filters
    except json.JSONDecodeError as e:
        print("âš ï¸ JSON decoding error:", e)
        return {}

# === SIMPLE FILTER-BASED MATCHING ===
def match_houses(user_query, top_k=5):
    filters = extract_filters_with_gpt(user_query)
    filtered = housing_data.copy()
    print(filters)

    if filters.get('min_sqft') is not None:
        filtered = filtered[filtered['SQFT'] >= filters['min_sqft']]
    if filters.get('min_bedrooms') is not None:
        filtered = filtered[filtered['BEDS'] == filters['min_bedrooms']]
    if filters.get('min_bathrooms') is not None:
        filtered = filtered[filtered['BATHS'] == filters['min_bathrooms']]
    if filters.get('max_price') is not None and 'RENT_PRICE' in filtered.columns:
        filtered = filtered[filtered['RENT_PRICE'] <= filters['max_price']]
    if filters.get('building_type'):
        filtered = filtered[filtered['BUILDING_TYPE'].str.lower().str.contains(filters['building_type'].lower())]
    if filters.get('amenities_required'):
        for amenity in filters['amenities_required']:
            col = amenity.upper()
            if col in filtered.columns:
                filtered = filtered[filtered[col] == 'Y']

    if filtered.empty:
        print("âŒ No listings match your criteria.")
        return pd.DataFrame() 

    # Optional: sort by shopping or food score
    score_cols = [col for col in ['Shopping', 'Food & Dining', 'Fitness & Recreation'] if col in filtered.columns]
    filtered["score"] = filtered[score_cols].sum(axis=1) if score_cols else 0

    matches = filtered.sort_values(by="score", ascending=False).head(top_k)

    print("\nðŸ  Top Matches:")
    for _, row in matches.iterrows():
        desc = f"{row['SQFT']} sqft | {row['BEDS']} bd / {row['BATHS']} ba | {row['BUILDING_TYPE']} | ${row['RENT_PRICE']}"
        amenities = [col for col in ['POOL', 'GYM', 'GARAGE', 'FURNISHED', 'DOORMAN', 'CLUBHOUSE'] if row.get(col, 'N') == 'Y']
        print(f"ðŸ·ï¸ {desc}")
        if amenities:
            print(f"ðŸ› ï¸ Amenities: {', '.join(amenities)}")
        # ðŸ“Š Display normalized scores for all three categories if available
        score_parts = []
        if 'Shopping' in row and pd.notna(row['Shopping']):
            score_parts.append(f"ðŸ›ï¸ Shopping: {row['Shopping']:.2f}")
        if 'Food & Dining' in row and pd.notna(row['Food & Dining']):
            score_parts.append(f"ðŸ½ï¸ Food: {row['Food & Dining']:.2f}")
        if 'Fitness & Recreation' in row and pd.notna(row['Fitness & Recreation']):
            score_parts.append(f"ðŸ‹ï¸ Fitness: {row['Fitness & Recreation']:.2f}")

        if score_parts:
            print(f"ðŸ“Š Nearby Scores: {' | '.join(score_parts)}")
        else:
            print("ðŸ“Š Nearby Scores: N/A")

        print("-" * 50)
    return matches

# === RUN MATCHING ===
if __name__ == "__main__":
    while True:
        query = input("ðŸ§  What kind of place are you looking for?\n> ").strip()
        if not query:
            break
        match_houses(query)